<!doctype html>
<html>
    <head>
        <title></title>        
        <style>
            body{ background-color: grey; }
            canvas{ background-color: rgb(110, 196, 218); }
			textarea{ background-color: black; foreground-color: white;}

            *{
            font-family: Arial, Helvetica, sans-serif;   
            }
            #log {
                position: absolute;
                top:50px;
                left: 100px;
                z-index: 300;
            }
        </style>
    </head>
    <body>
        </div>
            <div id="log">
                Up: w<br/>
                Down: s<br/>
                Left: a<br/>
                Right: d<br/>
                Zoom: c<br/>
                ZoomOut: z<br/>
            </div>    
    	<center>
            		            
            <canvas id="my-canvas" width="1000" height="800">
            	Your browser does not support the HTML5 canvas element.
    		</canvas>    		
    	</center>
        <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
        <script type="text/javascript" src="js/gl-matrix.js"></script>
        <script src="modulo-geometria.js"></script>
        <script type="module" src="objeto3D.js"></script>
        <script id="shader-vs" type="x-shader/x-vertex">

            precision highp float;

            attribute vec3 aVertexPosition;
            attribute vec3 aVertexNormal;

            uniform mat4 modelMatrix;            
            uniform mat4 viewMatrix;
            uniform mat4 projMatrix;

            uniform mat4 normalMatrix;

            varying vec3 vNormal;    
            varying vec3 vPosWorld;  

            void main(void) {
                gl_Position = projMatrix * viewMatrix * modelMatrix * vec4(aVertexPosition, 1.0);

                vPosWorld=(modelMatrix*vec4(aVertexPosition,1.0)).xyz;    //la posicion en coordenadas de mundo
                vNormal=(normalMatrix*vec4(aVertexNormal,1.0)).xyz;       //la normal en coordenadas de mundo                
                
            }
        </script>

        <script id="shader-fs" type="x-shader/x-fragment">
            precision highp float;
            varying vec3 vNormal;
            varying vec3 vPosWorld;

            void main(void) {

                vec3 lightVec=normalize(vec3(0.0,5.0,10.0)-vPosWorld);
                vec3 diffColor=mix(vec3(0.7,0.7,0.7),vNormal,0.4);
                vec3 color=dot(lightVec,vNormal)*diffColor+vec3(0.2,0.2,0.2);

               gl_FragColor = vec4(color,1.0);
            }
        </script>
        
        <script type="module" >

            import {Objeto3D}  from './objeto3D.js';
            import {SuperficieBarrido} from './util/superficieBarrido.js'
            import {Curva} from './util/curvas.js'
            import {Carretera} from './util/carretera.js'
            import {Torre} from './util/torre.js'
            import {Punto} from './util/punto.js'
            var mat4=glMatrix.mat4;
            var vec3=glMatrix.vec3;

            var gl = null,
            canvas = null,

            glProgram = null,
            fragmentShader = null,
            vertexShader = null;
                
               
            var modelMatrix = mat4.create();
            var viewMatrix = mat4.create();
            var projMatrix = mat4.create();
            
            var escena = null
            var hijo1 = null
            var hijo2 = null
            var torre1 = null

           
            function initWebGL(){

                canvas = document.getElementById("my-canvas");  

                try{
                    gl = canvas.getContext("webgl");      

                }catch(e){
                    alert(  "Error: Your browser does not appear to support WebGL.");
                }

                if(gl) {

                    setupWebGL();
                    initShaders();

                                    

                    let curva  = new Curva("bezier2",[
                        vec3.fromValues(-1,-1,0),
                        vec3.fromValues(0,-1,0),
                        vec3.fromValues(1,-1,0),
                    ])
                    curva.concat(new Curva("bezier2",[
                        vec3.fromValues(1,-1,0),
                        vec3.fromValues(1,0,0),
                        vec3.fromValues(1,1,0),
                    ]))

                    curva.concat(new Curva("bezier2",[
                        vec3.fromValues(1,1,0),
                        vec3.fromValues(0,1,0),
                        vec3.fromValues(-1,1,0),
                    ]))

                    curva.concat(new Curva("bezier2",[
                        vec3.fromValues(-1,1,0),
                        vec3.fromValues(-1,0,0),
                        vec3.fromValues(-1,-1,0),
                    ]))

                    let curvaR1  = new Curva("bezier2",[
                        vec3.fromValues(0,0,-3),
                        vec3.fromValues(0,0,-2.5),
                        vec3.fromValues(0,0,-2),
                    ])
                    curvaR1.setBiNormal(vec3.fromValues(-1,0,0))

                    let curvaR2 = new Curva('bezier2',[
                        vec3.fromValues(0,0,-2),
                        vec3.fromValues(0,1,0),
                        vec3.fromValues(0,0,2),
                    ])
                    curvaR2.setBiNormal(vec3.fromValues(-1,0,0))
                    curvaR1.concat(curvaR2)

                    let curvaR3 = new Curva('bezier2',[
                        vec3.fromValues(0,0,2),
                        vec3.fromValues(0,0,2.5),
                        vec3.fromValues(0,0,3),
                    ])
                    curvaR3.setBiNormal(vec3.fromValues(-1,0,0))
                    curvaR1.concat(curvaR3)

                    
                    var discretizacion = curva.getDiscretizacion(0.5)
                    var drecorrido = curvaR1.getDiscretizacion(0.5)
                    var recorrido = []
                    for(var i=0; i< drecorrido.length; i++){

                        var biNormal = drecorrido[i].getBiNormal()
                        var normal = drecorrido[i].getNormal()
                        var tang = drecorrido[i].getTang()
                        var coords = drecorrido[i].getCoords()

                        var matrizLvli = mat4.fromValues(
                            -biNormal[0],-biNormal[1],-biNormal[2],0,
                            normal[0],normal[1],normal[2],0,
                            tang[0],tang[1],tang[2],0,
                            coords[0],coords[1],coords[2],1)
                            
                        recorrido.push(matrizLvli)
                        }
                    
                


                    
                    var lvl0 = mat4.fromValues(
                        1,0,0,0,
                        0,1,0,0,
                        0,0,1,-3,
                        0,0,0,1
                    )

                    var lvl1 = mat4.fromValues(
                        1,0,0,0,
                        0,1,0,0,
                        0,0,1,-2,
                        0,0,0,1
                    )

                    var lvl2 = mat4.fromValues(
                        1, 0,    0    ,0,
                        0, 0.707,0.707,0.5,
                        0,-0.707,0.707,-1,
                        0, 0,    0    ,1
                    )
                    
                    var lvl3 = mat4.fromValues(
                        1,0,0,0,
                        0,1,0,1,
                        0,0,1,0,
                        0,0,0,1
                    )

                    var lvl4 = mat4.fromValues(
                        1, 0,    0    ,0,
                        0, 0.707,0.707,0.5,
                        0, 0.707,-0.707,1,
                        0, 0,    0    ,1
                    )

                    var lvl5 = mat4.fromValues(
                        1,0,0,0,
                        0,1,0,0,
                        0,0,1,2,
                        0,0,0,1
                    )

                    var lvl6 = mat4.fromValues(
                        1,0,0,0,
                        0,1,0,0,
                        0,0,1,3,
                        0,0,0,1
                    )

                    mat4.transpose(lvl0,lvl0)
                    mat4.transpose(lvl1,lvl1)
                    mat4.transpose(lvl2,lvl2)
                    mat4.transpose(lvl3,lvl3)
                    mat4.transpose(lvl4,lvl4)
                    mat4.transpose(lvl5,lvl5)
                    mat4.transpose(lvl6,lvl6)
                    //recorrido = [lvl0,lvl1,lvl2,lvl3,lvl4,lvl5,lvl6]
                    

                    let carretera = new Carretera()
                    discretizacion = carretera.getPerfil(0.1)
                    var sup = new SuperficieBarrido(discretizacion,recorrido)

                    escena = new Objeto3D();
                    escena.setPosicion(vec3.fromValues(0,0,0))
                    
                    var plano = new Objeto3D()
                    var buffersPlano = crearGeometria("plano",40,40)
                    plano.setGeometria(buffersPlano[0],buffersPlano[1],buffersPlano[2]) 
                    plano.setEscala(vec3.fromValues(10,10,10))
                    plano.setPosicion(vec3.fromValues(0,-10,0))
                    escena.agregarHijo(plano)


                    var esfera = new Objeto3D()
                    var buffersEsfera = crearGeometria("esfera",40,40)
                    esfera.setGeometria(buffersEsfera[0],buffersEsfera[1],buffersEsfera[2]) 
                    esfera.setPosicion(vec3.fromValues(0,5,10))
                    esfera.setEscala(vec3.fromValues(0.25,0.25,0.25))
                    escena.agregarHijo(esfera)

                    hijo1 = new Objeto3D() //carretera
                    hijo1.setGeometria(sup.getPositionBuffer(),sup.getNormalBuffer(),sup.getIndexBuffer())
                    //hijo1.setPosicion(vec3.fromValues(0,-4,0))
                    hijo1.setEscala(vec3.fromValues(0.5,1,2))
                    hijo1.setRotacion([Math.PI/2,vec3.fromValues(0,1,0)])
                    escena.agregarHijo(hijo1)
                          
                    setupVertexShaderMatrix();
                    tick();   

                }else{    
                    alert(  "Error: Your browser does not appear to support WebGL.");
                }

            }
           

            function setupWebGL(){
                gl.enable(gl.DEPTH_TEST);
                //set the clear color
                gl.clearColor(0.1, 0.1, 0.2, 1.0);     
                gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);     
    
                gl.viewport(0, 0, canvas.width, canvas.height);

                // Matrix de Proyeccion Perspectiva

                mat4.perspective(projMatrix,45, canvas.width / canvas.height, 0.1, 100.0);
                
                mat4.identity(modelMatrix);
                //mat4.rotate(modelMatrix,modelMatrix, -1.57078, [0.0, 0.0, 1.0]);

                mat4.identity(viewMatrix);
                mat4.translate(viewMatrix,viewMatrix, [0.0, 0.0, 20.0]);
            }
                    
                    
            function initShaders() {
                //get shader source
                var fs_source = document.getElementById('shader-fs').innerHTML,
                    vs_source = document.getElementById('shader-vs').innerHTML;

                //compile shaders    
                vertexShader = makeShader(vs_source, gl.VERTEX_SHADER);
                fragmentShader = makeShader(fs_source, gl.FRAGMENT_SHADER);
                
                //create program
                glProgram = gl.createProgram();
                
                //attach and link shaders to the program
                gl.attachShader(glProgram, vertexShader);
                gl.attachShader(glProgram, fragmentShader);
                gl.linkProgram(glProgram);

                if (!gl.getProgramParameter(glProgram, gl.LINK_STATUS)) {
                    alert("Unable to initialize the shader program.");
                }
                
                //use program
                gl.useProgram(glProgram);
            }
            
            function makeShader(src, type){
                //compile the vertex shader
                var shader = gl.createShader(type);
                gl.shaderSource(shader, src);
                gl.compileShader(shader);

                if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                    console.log("Error compiling shader: " + gl.getShaderInfoLog(shader));
                }
                return shader;
            }


            function setupVertexShaderMatrix(){
                var viewMatrixUniform  = gl.getUniformLocation(glProgram, "viewMatrix");
                var projMatrixUniform  = gl.getUniformLocation(glProgram, "projMatrix");

                gl.uniformMatrix4fv(viewMatrixUniform, false, viewMatrix);
                gl.uniformMatrix4fv(projMatrixUniform, false, projMatrix);
            }                  
            
            function drawScene(){
                setupVertexShaderMatrix()
                escena.dibujar(modelMatrix,gl,glProgram,viewMatrix)
            }

 
            var offset = 0
            var radio = 30
            var alpha = Math.PI*3/2
            var beta = Math.PI/2
            var speed = 0.05
            $('body').on("keydown",function(event){
                switch(event.key){
                    case "a":
                        alpha+=speed
                    break;

                    case "d":
                        alpha-=speed
                    break;

                    case "w":
                        beta-=speed
                    break;

                    case "s":
                        beta+=speed
                    break;

                    case "z":
                        radio+=speed*10
                    break;
                    
                    case "c":
                        radio-=speed*10
                    break;
                }
                if (beta<0) beta=0;
		        if (beta>Math.PI) beta=Math.PI;
            });   
            function animate(){
                offset += 0.1

                hijo1.setRotacion([offset*0.05,vec3.fromValues(0,1,0)])
                mat4.identity(viewMatrix)
               

                var x = radio * Math.sin(beta)* Math.cos(alpha)
                var z = radio * Math.sin(beta)* Math.sin(alpha)
                var y = radio * Math.cos(beta)

                mat4.lookAt(viewMatrix, [x,y,z], [0,0,0], [0,1,0])

            
                //hijo1.setPosicion(vec3.fromValues(-2+Math.sin(offset),0,0))
                //hijo2.setPosicion(vec3.fromValues(3+Math.sin(offset),0,0))
            }
            
            function tick(){

                requestAnimationFrame(tick);
                drawScene();
                animate();
            }

            window.onload=initWebGL;

        </script>


    </body>
</html>
