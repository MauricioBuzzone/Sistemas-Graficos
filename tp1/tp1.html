<!doctype html>
<html>
    <head>
        <title></title>        
        <style>
            body{ background-color: grey; }
            canvas{ background-color: rgb(110, 196, 218); }
			textarea{ background-color: black; foreground-color: white;}

            *{
            font-family: Arial, Helvetica, sans-serif;   
            }
            #log {
                position: absolute;
                top:50px;
                left: 100px;
                z-index: 300;
            }
        </style>
    </head>
    <body>
        </div>
            <div id="log">
                Up: w<br/>
                Down: s<br/>
                Left: a<br/>
                Right: d<br/>
                Zoom: c<br/>
                ZoomOut: z<br/>
            </div>    
    	<center>
            		            
            <canvas id="my-canvas" width="1000" height="800">
            	Your browser does not support the HTML5 canvas element.
    		</canvas>    		
    	</center>
        <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
        <script type="text/javascript" src="js/gl-matrix.js"></script>
        <script src="dat.gui.min.js"></script>
        <script src="modulo-geometria.js"></script>
        <script type="module" src="objeto3D.js"></script>
        <script id="shader-vs" type="x-shader/x-vertex">

            precision highp float;

            attribute vec3 aVertexPosition;
            attribute vec3 aVertexNormal;

            uniform mat4 modelMatrix;            
            uniform mat4 viewMatrix;
            uniform mat4 projMatrix;

            uniform mat4 normalMatrix;

            varying vec3 vNormal;    
            varying vec3 vPosWorld;  

            void main(void) {
                gl_Position = projMatrix * viewMatrix * modelMatrix * vec4(aVertexPosition, 1.0);

                vPosWorld=(modelMatrix*vec4(aVertexPosition,1.0)).xyz;    //la posicion en coordenadas de mundo
                vNormal=(normalMatrix*vec4(aVertexNormal,1.0)).xyz;       //la normal en coordenadas de mundo                
                
            }
        </script>

        <script id="shader-fs" type="x-shader/x-fragment">
            precision highp float;
            varying vec3 vNormal;
            varying vec3 vPosWorld;

            void main(void) {

                vec3 lightVec=normalize(vec3(0.0,10.0,0.0)-vPosWorld);
                vec3 diffColor=mix(vec3(0.7,0.7,0.7),vNormal,0.4);
                vec3 color=dot(lightVec,vNormal)*diffColor+vec3(0.2,0.2,0.2);

               gl_FragColor = vec4(color,1.0);
            }
        </script>
        
        <script type="module" >

            import {Objeto3D}  from './objeto3D.js';
            import {SuperficieBarrido} from './util/superficieBarrido.js'
            import {Curva, Bases} from './util/curva.js'
            import {CurvaGenerica} from './util/curvaGenerica.js'
            import {Carretera} from './util/carretera.js'
            import {Cable} from './util/cable.js'
            import {Terreno} from './util/terreno.js'
            import {Torre} from './util/torre.js'
            import {Punto} from './util/punto.js'
            var mat4=glMatrix.mat4;
            var vec3=glMatrix.vec3;

            var gl = null,
            canvas = null,

            glProgram = null,
            fragmentShader = null,
            vertexShader = null;
                
               
            var modelMatrix = mat4.create();
            var viewMatrix = mat4.create();
            var projMatrix = mat4.create();
            
            var vertexShaderFile="vertex-shader.glsl";

            var nodoPadre = null
            var hijo1 = null
            var hijo2 = null
            var torre1 = null

            var escena={
                alturaMaxPuente:5,
                alturaTorre:15,
                alturaRio:-2,
                separacionTorres:16,
                s1:5,
                generar:function(){
                    crearEscena()
                },      
            };

            function initWebGL(){

                canvas = document.getElementById("my-canvas");  

                try{
                    gl = canvas.getContext("webgl");      

                }catch(e){
                    alert(  "Error: Your browser does not appear to support WebGL.");
                }

                if(gl) {

                    setupWebGL();
                    GUI();
                    crearEscena();
                    
                    tick();   

                }else{    
                    alert(  "Error: Your browser does not appear to support WebGL.");
                }

            }
           

            function crearEscena(){
                nodoPadre = new Objeto3D();
                nodoPadre.setPosicion(vec3.fromValues(0,0,0))
                
                // Creo el terreno
                let terreno = new Terreno(0.1,0.01)
                terreno.setEscala(vec3.fromValues(2,1,1))
                terreno.setPosicion(vec3.fromValues(0,0,0))
                nodoPadre.agregarHijo(terreno)
                
                // Creo la carretera
                let modeloCarretera = new Carretera(escena.alturaMaxPuente)
                var supCarretera = new SuperficieBarrido(
                    modeloCarretera.getPerfil(0.1),
                    modeloCarretera.getRecorrido(0.1)
                )
                var carretera = new Objeto3D()
                carretera.setGeometria(
                    supCarretera.getPositionBuffer(),
                    supCarretera.getNormalBuffer(),
                    supCarretera.getIndexBuffer()
                )
                carretera.setRotacion([Math.PI/2,vec3.fromValues(0,1,0)])
                carretera.setPosicion(vec3.fromValues(0,1.01,0))
                carretera.setEscala(vec3.fromValues(0.25,1,2))
                nodoPadre.agregarHijo(carretera)


                // Creo las 4 torres del puente 
                let modeloTorre = new Torre(escena.alturaTorre)
                var suptorre = new SuperficieBarrido(
                    modeloTorre.getPerfil(0.1),
                    modeloTorre.getRecorrido(0.1)
                )
                let torres = []
                for(let i=0; i<4; i++){
                    var torrei = new Objeto3D()
                    torrei.setGeometria(
                        suptorre.getPositionBuffer(),
                        suptorre.getNormalBuffer(),
                        suptorre.getIndexBuffer()
                    )
                    torrei.setRotacion([-Math.PI/2,vec3.fromValues(0,0,1)])
                    nodoPadre.agregarHijo(torrei)
                    torres.push(torrei)
                }
                torres[0].setPosicion(vec3.fromValues(escena.separacionTorres/2,-5,2.25))
                torres[1].setPosicion(vec3.fromValues(escena.separacionTorres/2,-5,-2.25))
                torres[2].setPosicion(vec3.fromValues(-escena.separacionTorres/2,-5,2.25))
                torres[3].setPosicion(vec3.fromValues(-escena.separacionTorres/2,-5,-2.25))

                let comeinzoPuente = modeloCarretera.getRecorridoDisc(0.5)[1].getCoords()
                let finPuente = modeloCarretera.getRecorridoDisc(0.5)[7].getCoords()


                let puntosDeControl = [
                    vec3.fromValues(0,comeinzoPuente[1],2*comeinzoPuente[2]),
                    vec3.fromValues(0,(escena.alturaTorre-6)*2/3,2*comeinzoPuente[2]*1/3),
                    vec3.fromValues(0,escena.alturaTorre-6,-escena.separacionTorres/2),
                    vec3.fromValues(0,escena.alturaMaxPuente+1,0),
                    vec3.fromValues(0,escena.alturaTorre-6,escena.separacionTorres/2),
                    vec3.fromValues(0,(escena.alturaTorre-6)*2/3,2*finPuente[2]*1/3),
                    vec3.fromValues(0,finPuente[1],2*finPuente[2]),
                ]

                console.log(puntosDeControl)
                let recorridoCable = new CurvaGenerica([
                    new Curva(Bases.Bezier2,[
                        puntosDeControl[0],
                        puntosDeControl[1],
                        puntosDeControl[2],
                    ]),
                    new Curva(Bases.Bezier2,[
                        puntosDeControl[2],
                        puntosDeControl[3],
                        puntosDeControl[4],
                    ]),
                    new Curva(Bases.Bezier2,[
                        puntosDeControl[4],
                        puntosDeControl[5],
                        puntosDeControl[6],
                    ]),
                ])

                // Creo los cables del puente                
                let modeloCable = new Cable()
                modeloCable.setRecorrido(recorridoCable)

                var supcable = new SuperficieBarrido(
                    modeloCable.getPerfil(0.1),
                    modeloCable.getRecorrido(0.05)
                )

                var cable = new Objeto3D()
                cable.setGeometria(
                    supcable.getPositionBuffer(),
                    supcable.getNormalBuffer(),
                    supcable.getIndexBuffer()
                )
                cable.setRotacion([Math.PI/2,vec3.fromValues(0,1,0)])
                cable.setPosicion(vec3.fromValues(0,-0.5,2.25))

                var cable2 = new Objeto3D()
                cable2.setGeometria(
                    supcable.getPositionBuffer(),
                    supcable.getNormalBuffer(),
                    supcable.getIndexBuffer()
                )
                cable2.setRotacion([Math.PI/2,vec3.fromValues(0,1,0)])
                cable2.setPosicion(vec3.fromValues(0,-0.5,-2.25))

                nodoPadre.agregarHijo(cable)
                nodoPadre.agregarHijo(cable2)
                
                
                var esfera = new Objeto3D()
                var buffersEsfera = crearGeometria("esfera",40,40)
                esfera.setGeometria(buffersEsfera[0],buffersEsfera[1],buffersEsfera[2]) 
                esfera.setPosicion(vec3.fromValues(10,30,10))
                esfera.setEscala(vec3.fromValues(0.25,0.25,0.25))
                nodoPadre.agregarHijo(esfera)
            }


            function GUI (){
                var gui = new dat.GUI();		
                var f1 = gui.addFolder('Menú');		
            
                f1.add(escena, 'alturaMaxPuente', 0.0, 12.0).name("altura puente")
                    .step(1)
                    .onChange(function(alturaPuente){
                        escena.alturaMaxPuente = alturaPuente
                });
                f1.add(escena, 'alturaTorre', escena.alturaMaxPuente, 30.0).name("altura torres")
                    .step(1)
                    .onChange(function(alturaTorre){
                    if (escena.alturaMaxPuente <= alturaTorre+7){
                        escena.alturaTorre = alturaTorre
                    }else{
                        escena.alturaTorre = escena.alturaMaxPuente +7
                    }
                    
                });
                f1.add(escena, 's1', -10.0, 30.0).name("separacion tensores").step(1);
                f1.add(escena, 'alturaRio', -10.0, 30.0).name("altura rio").step(1);
                f1.add(escena, 'generar').name("generar");

                f1.open(); 
            };


            function setupWebGL(){
                gl.enable(gl.DEPTH_TEST);
                //set the clear color
                gl.clearColor(0.1, 0.1, 0.2, 1.0);     
                gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);     
    
                gl.viewport(0, 0, canvas.width, canvas.height);

                // Matrix de Proyeccion Perspectiva

                mat4.perspective(projMatrix,45, canvas.width / canvas.height, 0.1, 150.0);
                
                mat4.identity(modelMatrix);
                mat4.identity(viewMatrix);
                mat4.translate(viewMatrix,viewMatrix, [0.0, 0.0, 20.0]);
            }
                
            function drawScene(){
                //setupVertexShaderMatrix()
                nodoPadre.dibujar(modelMatrix,gl,viewMatrix,projMatrix)
            }

 
            var offset = 0
            var radio = 30
            var alpha = Math.PI*3/2
            var beta = Math.PI/2
            var speed = 0.05
            $('body').on("keydown",function(event){
                switch(event.key){
                    case "a":
                        alpha+=speed
                    break;

                    case "d":
                        alpha-=speed
                    break;

                    case "w":
                        beta-=speed
                    break;

                    case "s":
                        beta+=speed
                    break;

                    case "z":
                        radio+=speed*10
                    break;
                    
                    case "c":
                        radio-=speed*10
                    break;
                }

                if (radio < 0.5) radio = 0.5
                if (beta<0.1) beta=0.1;
		        if (beta>=Math.PI) beta=Math.PI;
            });   
            function animate(){
                offset += 0.1

                //hijo1.setRotacion([offset*0.1,vec3.fromValues(0,1,0)])
                mat4.identity(viewMatrix)
               

                var x = radio * Math.sin(beta)* Math.cos(alpha)
                var z = radio * Math.sin(beta)* Math.sin(alpha)
                var y = radio * Math.cos(beta)

                mat4.lookAt(viewMatrix, [x,y,z], [0,0,0], [0,1,0])

            }
            
            function tick(){

                requestAnimationFrame(tick);
                drawScene();
                animate();
            }

            window.onload=initWebGL;

        </script>


    </body>
</html>
